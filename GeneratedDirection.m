function SampleSolution   = GeneratedDirection(Problem,Population,RefV)
%% Generate the reference vector 
%  and assign with individual that has the minimum angle
    BoundRefV               = eye(Problem.M,Problem.M);
    BoundRefV(BoundRefV==0) = 10e-7;
    RefV=[RefV;BoundRefV];
    Obj=Population.objs;
    [associate,~] = Assign(Population,RefV);
% Associate each solution with its nearest reference point
    for i = 1:Problem.N
       current{i,1} = find(associate == i);
    end  
    for i= 1:Problem.N
        if length(current{i,1})>1
            Cosine   = 1 - pdist2(Obj(current{i,1},:),RefV(i,:),'cosine');
            Distance = repmat(sqrt(sum(Obj(current{i,1},:).^2,2)),1,1).*sqrt(1-Cosine.^2);
            [~,ind] = sort(Distance,'ascend');
            Best(i,1) = current{i,1}(ind(1));
        else if length(current{i,1})==1
                Best(i,1) = current{i,1}(1);
            end
        end
    end
% Non-dominated sorting of selected solutions(representative solutions)
    Next=Best~=0;
    Pop=Population(Next==1);
    N=size(Pop,2);
    [FrontNo,~] = NDSort(Pop.objs,N);
    DirectPoint =Pop(FrontNo==1);

%% Generate search directions and perform first reorganization
    SampleSolution  = GenerateSampleSolution(Problem,DirectPoint);
    GradSolution= LineSearch(Problem,DirectPoint);
    SampleSolution=[SampleSolution,GradSolution];
end
  
function SampleSolution = GenerateSampleSolution(Problem,DirectPoint)
    Nw=size(DirectPoint,2);
    Ns=Problem.D;
% Generate search directions based on the upper and lower boundaries of the decision space
    DpDec      = DirectPoint.decs;
    Upper      = Problem.upper; 
    Lower      = Problem.lower;
    Directnorm = [sqrt(sum((DpDec - repmat(Lower,Nw,1)).^2,2));sqrt(sum((DpDec - repmat(Upper,Nw,1)).^2,2))];
    Direction  = [DpDec - repmat(Lower,Nw,1);DpDec - repmat(Upper,Nw,1)]./repmat(Directnorm,1,Problem.D);
% The first reorganization
% Sampling along the search direction generated by the representative solution 
% and the upper and lower bounds of the search space    
    Intervalmax  = sqrt(sum((Upper-Lower).^2,2));
    Intervalmin  = 0;
    Nw           = 2*Nw;
    RandSample   = Intervalmin + rand(Ns,Nw)*(Intervalmax-Intervalmin);
    Nw = Nw/2;
    SampleSolution = [];
    for i = 1:Ns
       PopX = [repmat(Problem.lower,Nw,1) + repmat(RandSample(i,1:Nw)',1,Problem.D).* Direction(1:Nw,:);...
           repmat(Problem.upper,Nw,1) + repmat(RandSample(i,Nw+1:end)',1,Problem.D).* Direction(Nw+1:end,:)];
       PopX = max(min(repmat(Problem.upper,size(PopX,1),1),PopX),repmat(Problem.lower,size(PopX,1),1));
       SampleSolutiontemp = Problem.Evaluation(PopX);
       SampleSolution = [SampleSolution,SampleSolutiontemp];
   end
end
    
function GradSolution = LineSearch(Problem,GuidingSolution)
DpDec= GuidingSolution.decs;
if size(DpDec,1)<Problem.M
    DpDec=[DpDec;DpDec;DpDec;DpDec];
end
A=size(DpDec,1);
G=[];
Z=[];
for i=1:A
% Generate gradient direction
    [W,~] = UniformPoint(A,Problem.M,'MUD');
    df= Problem.CalObjGrad(DpDec(i,:))';
    site = (any(df<0,2)&any(df>0,2))';
    df   = df*W(i,:)';
    dk=-df;
% The first reorganization
% Search along direction lines that contain gradient information
    for step=0:9
        mu     = rand(1,Problem.D) < 1/sum(site);
        OffDec = DpDec(i,:) + ~site.*0.5^step.*dk' + ...,
            mu.*site*0.5^step.*(DpDec(randi(end),:)-DpDec(randi(end),:));
        G=[G;OffDec];
    end
    Z=[Z;G];
end
Z=unique(Z,'rows');
Offspring = Problem.Evaluation(Z);
GradSolution = Offspring((NDSort(Offspring.objs,1)==1));
end
    
function [associate,Cosinemax] = Assign(PopCom,RefV)
% Assign individuals
Obj = PopCom.objs;
Obj = (Obj-repmat(min(Obj),length(PopCom),1))./(repmat(max(Obj),length(PopCom),1)-repmat(min(Obj),length(PopCom),1));
Cosinetemp = pdist2(Obj,RefV,'cosine');
Cosine = 1-Cosinetemp;
[Cosinemax,associate] = max(Cosine,[],2);
end